# Workflow for building the Micronaut JAR and deploying via AWS CDK.
#
# Triggers:
#   - Manual (workflow_dispatch): choose environment (development | production) and branch.
#     Deploying to production is only allowed from the master branch; the guard job
#     enforces this before anything else runs.
#   - Automatic (pull_request): any PR opened/updated/reopened deploys to development only.
#     Production is never touched automatically.
#
# Environments:
#   - development: no approval required, uses secrets.OPENROUTER_API_KEY from the
#                  "development" GitHub Environment.
#   - production:  requires manual approval (configure a required reviewer in
#                  Settings → Environments → production), uses secrets.OPENROUTER_API_KEY
#                  from the "production" GitHub Environment.
name: Build & Deploy to AWS CDK

# Grant the workflow permission to request OIDC id-tokens and read repository contents.
permissions:
  id-token: write
  contents: read

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - development
          - production
      branch:
        description: 'Branch to deploy (production only accepts master)'
        required: true
        default: 'master'
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  # ---------------------------------------------------------------------------
  # Guard: fail fast when a manual dispatch tries to deploy production from a
  # branch other than master. This is the only place this rule is enforced, so
  # it is explicit and visible in the job list.
  # ---------------------------------------------------------------------------
  guard:
    name: Validate deployment inputs
    runs-on: ubuntu-latest
    steps:
      - name: Block production deploy from non-master branch
        if: >
          github.event_name == 'workflow_dispatch' &&
          inputs.environment == 'production' &&
          inputs.branch != 'master'
        run: |
          echo "ERROR: Production can only be deployed from master. Got branch: '${{ inputs.branch }}'." >&2
          exit 1

      - name: Confirm deployment target
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "Automatic PR trigger → deploying to: development"
          else
            echo "Manual trigger → deploying to: ${{ inputs.environment }} from branch: ${{ inputs.branch }}"
          fi

  # ---------------------------------------------------------------------------
  # Build: compile and test the JAR, then upload it as an artifact.
  # ---------------------------------------------------------------------------
  build:
    name: Build JAR
    needs: guard
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          # For manual dispatches, check out the requested branch.
          # For PRs, the default checkout (merge commit) is correct.
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.branch || github.sha }}

      - name: Verify branch exists
        # Only relevant for manual dispatches. Provides a clear error message if the
        # branch input is mistyped, instead of letting a later step fail cryptically.
        if: github.event_name == 'workflow_dispatch'
        run: |
          if ! git show-ref --verify --quiet "refs/remotes/origin/${{ inputs.branch }}"; then
            echo "ERROR: Branch '${{ inputs.branch }}' does not exist in the repository." >&2
            exit 1
          fi
          echo "Branch '${{ inputs.branch }}' verified."

      - name: Set up JDK 21
        uses: actions/setup-java@v5
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Cache Gradle
        uses: actions/cache@v5
        with:
          path: ~/.gradle/caches
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Run CI tests
        # Fail early if any test fails, before building the deployable artifact.
        run: ./gradlew --no-daemon ciTest

      - name: Build JAR (shadowJar)
        run: ./gradlew --no-daemon clean shadowJar

      - name: Upload JAR artifact
        uses: actions/upload-artifact@v6
        with:
          name: lambda-jar
          path: build/libs/*.jar

  # ---------------------------------------------------------------------------
  # Deploy: download the JAR and deploy the correct CDK stack for the target
  # environment. The GitHub Environment binding is what gates production behind
  # a required manual approval (configured in Settings → Environments).
  # ---------------------------------------------------------------------------
  deploy:
    name: Deploy to ${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'development' }}
    needs: build
    runs-on: ubuntu-latest
    environment:
      # Bind to the matching GitHub Environment so that:
      #   - development: deploys immediately (no approval required).
      #   - production:  waits for a required reviewer to approve
      #                  (configure in Settings → Environments → production).
      # Each environment holds its own OPENROUTER_API_KEY secret.
      name: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'development' }}
    steps:
      - name: Resolve deployment target
        id: target
        # Produce a single output used throughout this job to avoid repeating the ternary.
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ inputs.environment }}" >> "$GITHUB_OUTPUT"
          else
            echo "environment=development" >> "$GITHUB_OUTPUT"
          fi

      - name: Checkout code
        uses: actions/checkout@v6
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.branch || github.sha }}

      - name: Download JAR artifact
        uses: actions/download-artifact@v7
        with:
          name: lambda-jar
          path: build/libs

      - name: Verify JAR artifact exists
        run: |
          echo "Checking for build/libs/*.jar artifacts..."
          if ! ls build/libs/*.jar 1>/dev/null 2>&1; then
            echo "ERROR: No JAR found in build/libs. Ensure the build job produced an artifact." >&2
            exit 1
          fi
          echo "Found artifacts:"
          ls -1 build/libs/*.jar

      - name: Verify OPENROUTER_API_KEY is set
        # Do NOT print the key value. Only log that it is present and its length.
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        run: |
          if [ -z "$OPENROUTER_API_KEY" ]; then
            echo "ERROR: OPENROUTER_API_KEY secret is not set for the '${{ steps.target.outputs.environment }}' environment." >&2
            exit 1
          fi
          LEN=$(echo -n "$OPENROUTER_API_KEY" | wc -c | tr -d ' ')
          echo "OPENROUTER_API_KEY is set (length: $LEN, value: [REDACTED])."

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v6
        with:
          role-to-assume: arn:aws:iam::134267836527:role/github-cdk-deploy-role
          aws-region: eu-south-2
          audience: sts.amazonaws.com
          output-env-credentials: true

      - name: Set up Node.js for CDK
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      - name: Cache npm for CDK
        uses: actions/cache@v5
        with:
          path: |
            ~/.npm
            ~/.cache/npm
          key: ${{ runner.os }}-node-${{ hashFiles('cdk/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install AWS CDK CLI
        run: npm install -g aws-cdk

      - name: Install CDK dependencies
        run: cd cdk && npm install

      - name: Build CDK TypeScript
        run: cd cdk && npm run build

      - name: Validate CDK installation
        run: |
          node -v
          npm -v
          echo "CDK (global) version:" && npx cdk --version || true

      - name: Deploy with AWS CDK
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          TARGET_ENV: ${{ steps.target.outputs.environment }}
        run: |
          # Resolve the shadow JAR. Prefer *-all.jar (shadowJar output).
          CANDIDATE=$(ls build/libs/*-all.jar 2>/dev/null | head -n1)
          if [ -z "$CANDIDATE" ]; then
            CANDIDATE=$(ls -S build/libs/*.jar 2>/dev/null | head -n1)
          fi

          if [ -z "$CANDIDATE" ] || [ ! -f "$CANDIDATE" ]; then
            echo "ERROR: No usable JAR found in build/libs." >&2
            ls -la build/libs || true
            exit 1
          fi

          echo "Using JAR: $CANDIDATE"
          echo "Target CDK stack: ComplAILambdaStack-${TARGET_ENV}"

          export JAR_PATH="$CANDIDATE"
          cd cdk
          # Deploy only the stack for the target environment. The CDK app defines one
          # stack per environment; deploying by explicit name ensures the other stack
          # is never touched.
          npx cdk deploy "ComplAILambdaStack-${TARGET_ENV}" \
            --require-approval never \
            -c jarPath="$JAR_PATH" \
            -c environment="$TARGET_ENV" \
            --parameters OpenRouterApiKey="$OPENROUTER_API_KEY" \
            --outputs-file "../cdk-outputs-${TARGET_ENV}.json"

      - name: Upload CDK outputs
        uses: actions/upload-artifact@v6
        with:
          name: cdk-outputs-${{ steps.target.outputs.environment }}
          path: cdk-outputs-${{ steps.target.outputs.environment }}.json

  # ---------------------------------------------------------------------------
  # E2E: Run Bruno E2E tests after successful deploy to development
  # ---------------------------------------------------------------------------
  e2e:
    name: E2E API Tests (Bruno)
    needs: deploy
    if: needs.deploy.result == 'success' && needs.deploy.outputs.environment == 'development'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      - name: Install Bruno CLI
        run: npm install -g @usebruno/cli

      - name: Run Bruno E2E tests (development)
        working-directory: ./E2E-ComplAI
        run: >
          bru run . -r --env Development --reporter-json results.json

      - name: Upload Bruno E2E JSON report
        if: always()
        uses: actions/upload-artifact@v7
        with:
          name: bruno-e2e-json-report
          path: ./E2E-ComplAI/results.json

